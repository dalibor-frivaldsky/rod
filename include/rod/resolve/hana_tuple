#include <boost/hana.hpp>
#include <utility>


namespace rod { namespace resolve {

	namespace detail {

		template< typename T >
		constexpr auto generate_resolvers( T& v ) {
			return boost::hana::tuple(
				[&] { return v; },
				[&] ()-> T& { return v; },
				[&] { return &v; }
			);
		}

		template< typename T >
		constexpr auto generate_resolvers( T* v ) {
			return boost::hana::tuple(
				[&] { return *v; },
				[&] ()-> T& { return *v; },
				[&] { return v; }
			);
		}

	}

	template< typename M, typename Query >
	constexpr auto resolve( M& monad, Query query ) {
		return boost::hana::filter(
			monad | [] (auto& v) { return detail::generate_resolvers( v ); },
			[&] (auto&& resolver) {
				constexpr auto resolvableType = boost::hana::type_c<decltype(resolver)>;
		 		//constexpr auto matchesQuery = decltype(query(resolvableType)){};
				return decltype(query(resolvableType)){};
			}
		);
		/* | [&] (auto& resolver ) {
		 	constexpr auto resolvableType = boost::hana::type_c<decltype(resolver())>;
		 	constexpr auto matchesQuery = decltype(query(resolvableType)){};

		 	if constexpr( matchesQuery ) {
		 		return boost::hana::tuple(resolver);
		 	}
		 	else {
		 		return boost::hana::make_tuple();
		 	}
		 };*/
	}

}}